			QUIZZ DJANGO & CO
pr créer une bonne API Django:
- faire un dossier logs avec des logger.info & logger.errors
- vérifier que le nommage des fichiers & dossiers conforme aux
  normes DevOps
- fonctionne en Http & Https
- utiliser un client de test

1) créer nos class de modèles depuis les tables d'1 DB PG ?

REP : python manage.py inspectdb > models.py
- /!\ cette commande n'est qu'1 base à compléter ensuite car
      dès que ya des clés étrangères ça bloque
- /!\ if un column type de la DB n'est pas reconnue par DRF
      il est remplacé par TextField()
si on génère des urls basiques sans regex ds le app/urls.py, 
automatiquement leurs routes tiendront compte des primary key ID

2) how to use les décorateurs api_view en GET POST ?

REP : suffit d'écrire le décorateur juste la ligne au-dessus de
la fct définie ds les views.py


3) exécuter un curseur

REP : cursor.execute(
	"INSERT INTO table VALUES(%s,%s)", (int(id), string)
)

4) ouvrir le shell django :

REP : python manage.py shell

5) rename les fields dans un serializer :

REP : newName = serializer.CharField(source='former_name')
/!\ ne pas mettre de virgule à la fin
- if pr rename un champ ForeignKeyField alors :
REP : nom_du_club = serializers.PrimaryKeyRelatedField(
	source="club_pro", queryset=Clubs.objects.all()
)
avec la source + un queryset du Model lié par la foreignkey
sinon il affiche par la valeur ds la page du navigateur
+ il est possible qu'il faille add "to_field=field_name_lié" ds
  le model contenant la foreignkey
+ possible qu'il faille define des lookup fields ds le serializer
  file sinon mettre direct fields='__all__' mm si pas recommandé

dans models.py:
- when ForeignKeyField ds 1 table A => tjrs préciser le 
  nom du modèle lié et surtout pas le mettre entre simple/double quotes
  et évidemment pr que ça marche fo que ce modèle soit déclaré
  avant !
  , le 
  "models.DO_NOTHING, le db_column=champ_table1
  puis le to_field (donc le champ relié)
  très important de pas oublier le "to_field = champ_tableB" 
  sinon il prend la clé primaire "id" du modèle

dans serializers.py:
- ensuite fo surtout pas mettre de PrimaryKeyRelatedFied() sinon
  il prendra la clé primaire (liée à ce que j'ai écrit au-dessus)
- fo juste mettre un IntegerField ou CharField classique mais
  préciser la source en attribut 
  ex : IntegerField(source='champ_tableA.champ_tableB')
- quand on veut aller chercher une valeur de la tableA vers une
  tableC en passant par une table B, fo mentionner 3 champs:
  source=champ_tableA.champ_tableB.champ_tableC
- pr un UPDATE/PATCH => la doc technique affirme qu'on est
  obligés de passer par un PrimaryKeyRelatedField si on veut
  update un champ de foreign key, ne mettre que le nom du champ
  du modèle dans l'attribut source

dans le views.py:
- pr s'assurer que le serializer est valide, faire un :
  print(serializer.is_valid()) => renvoie un boolean
- pr visualiser les data validées par Django ds le serializer, can
  faire un print(serializer.validated_data)
- if fear ya error, can faire un print(serializer.errors)

6) l'OBJECTS des models :
- use objects.filter() to SELECT un champ en fct d'1 WHERE
- can placer plusieurs champs ds le objects.filter() avc virgule
- condition OR : séparer les conditions de champs par un |
- can filter multiple values pr un seul champ avec "__in"
  ex : 
      valuesList = ['algerie']
      pays = Pays.objects.filter(nom__in=valuesList)
- can les chainer: filter(...).count()
- can faire un print des attributs de l'objet récupéré par get()
  exemple : updated_statut = StatutWorkflow.objects.get(cle=key)
            print(updated_statut.libelle) => ça marche MAIS
MAIS MAIS MAIS
ATTENTION aux foreignKeyFields qui compliquent tout, faut encore
chaîner avec des "." pour aller chercher la valeur dans le model
étranger


7) dérouler les items d'un QuerySet :

REP : 
clubs = Clubs.objects.filter(pays="algerie")
for club in clubs:
	print(club.nom, club.pays)


8) afficher les champs de la table jointe

REP : ds le serializer, déclarer un new fieldname comme ça
	pays = serializers.CharField(source="club_pro.pays")
avc son type,
club_pro = foreign key,
pays = champ ciblé ds la table jointe

ça marche aussi avc les OneToOneField en place des ForeignKey
et 2ème méthode :
idClasse = serializers.PrimaryKeyRelatedField(
	source="id_classe",
	queryset=ClasseDetection.objects.all()
)


9) incruster un model dans un autre model :


REP :put "depth = 1" dans le serializer


10) filter un objet par sa clé étrangère :

REP : Joueurs.objects.filter(club_pro__pays='algerie')
avec club_pro = clé étrangère
et pays = champs ciblé


11) faire un double filtre

REP :
Joueurs.objects.filter(club_pro__pays='algerie', nom='hicham')


12) suppr un superuser :

REP :
> python manage.py shell
$ from django.contrib.auth.models import User
$ User.objects.get(username="blabla", is_superuser=True).delete()


13) pour modifier le nom d'un projet Django déjà existant

REP : https://stackoverflow.com/questions/18293875/easy-way-to-rename-a-django-project


14) pour filtrer un ForeignKey field

REP : fo tjrs mettre un "primary_key=True" sur le champ ciblé


15) to use un .get() sur un Model.objects :

REP : tjrs faire un try... except et mettre le Model.DoesNotExist
      ds le except


16) pr faire un vrai PATCH :

REP :
updated_statut = StatutWorkflow.objects.get(cle=key)
updated_statut.libelle = data.get("libelle", updated_statut.libelle)
updated_statut.save()
serializer = StatutWorkflowSerializer(updated_statut)

17) dans le serializer, pour cacher un champ à update

REP : mettre "write_only=True" dans le champ serializé

18) si on veut modifier une valeur d'1 champ serializé sans pour
autant modifier la mm valeur ds la DB :

REP :
- dans la view après le Pays.objects.all():
for p in pays:
        if p.nom == 'maroc':
            p.nom = 'Maroc
- ou bien dans le serializer :

18) désactiver l'interface web du navigateur pr tte vue DRF

REP:
REST_FRAMEWORK = {
	'DEFAULT_RENDERER_CLASSES': (
		'rest_framework.renderers.JSONRenderer',
		)
	}

19) pr formater une date en JJ/MM/YY depuis un serializer :

REP :
myDate = serializers.DateField(source="formerDate", 
				format="%d/%m/%Y")

20) pr gérer les permissions

REP:
créer un fichier safelist.py ds le dossier API et add une liste
d'IPs à aller filtrer et y créer une classe étendue de la classe
BasePermission du module permissions de rest_framework.
Ensuite add le paramètre DEFAULT_PERMISSION_CLASSES ds le fichier 
settings.py (ds l'objet REST_FRAMEWORK) et indiquer le chemin du
fichier safelist.py avec la notation pointée


21) pr add une colonne dans 1 table de la DB et l'add ds l'API

REP:
ajouter la colonne puis ajouter un champ ds les models et les
serializers => no need any new migrations !

22) pr lister les migrations à faire

REP:
python manage.py showmigrations --list

23) pr utiliser une date timestamp

REP:
dans models.py use un DateTimeField()
+ idem ds serializers.py et add les param suivants:
	- source
	- default_timezone (None if ds PGSQL without TZ)
	- allow_null si on veut laisser le client MAJ
	  la date à une valeur nulle

24) pr mettre en cache un endpoint

REP:
on doit récup la classe cache_page :
from django.views.decorators.cache import cache_page
juste au-dessus du décorateur @api_view, fo add un second
décorateur : @cache_page(60*15) => temps rétention 15min

-------Le WORKFLOW de Django REST Framework-----------------

Les permissions sont check at the very start of the view avant mm
que le body de la view soit exécutée. Si la permission fail au
moment d'appeler la view, alrs ça crée une erreur 403. ça peut
also créer une erreur 401 en fct du syst d'authentication. If ya
pas de paramètre de permissions, par défaut l'API fonctionnera avc
la valeur AllowAny


-------L'UTILISATION d'API_VIEW POUR CREER DES VIEWS--------

1) c'est de la progra fonctionnelle et non basée sur class

retirer les self et modifier les urls.py

2) l'avantage des class sur les fonctional views :

l'héritage qui évite la redondance


-------CREATION D'UN SYSTEME D'AUTHENTIFICATION------------

1) avec JWT :
- pip install pyjwt
- creer une class User à partir d'AbstractUser en précisant le
  USERNAME_FIELD correspondant à un champs à UNIQUE=True
- ds le settings.py entrer : AUTH_USER_MODEL = 'core.User' avc
  le nom de l'appli à la place de "core"
- entrer les param de coco à la DB
- ds le serializers.py créer 1 class UserSerializer avc le mdp en
  write_only + give him une fct create()
- ds les views.py créer les class de views
- add each class de view créée dans le urls.py et créer les routes
- avant de runserver : makemigrations + migrate

2) si jamais on doit le créer en milieu de code, suivre ce tuto:

https://code.djangoproject.com/ticket/25313
