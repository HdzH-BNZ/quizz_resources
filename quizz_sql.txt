			Mon Quizz PostgreSQL :

1) afficher la version used de PG :

REP :
SELECT version();
SELECT PostGIS_Version();

1.1) vérifier que la version de postgis est bien la bonne


REP :
ALTER EXTENSION postgis 
UPDATE TO "2.5.3"; => renvoie un message d'erreur comme quoi cest
déjà installé

2) créer un RÔLE

REP :
CREATE ROLE readonly;
GRANT CONNECT ON DATABASE db_anakin TO readonly;
GRANT USAGE ON SCHEMA public TO readonly;
GRANT SELECT ON TABLE test, test_bis TO readonly;

CREATE ROLE readwrite;
GRANT CONNECT ON DATABASE db_anakin TO readwrite;
GRANT USAGE, CREATE ON SCHEMA public TO readwrite;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE test, test_bis TO readwrite;
-- can also écrire : 
-- GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO readwrite;

/!\ SERIAL = pseudo-type de PG qui est en vrai un simple integer
qui dépend d'une séquence donc fo GRANT sur les séquences too

3) créer un USER et lui appliquer le RÔLE créé

REP:
CREATE USER anakin WITH LOGIN PASSWORD 'anakin';
GRANT readonly TO anakin;

CREATE USER scofield WITH LOGIN PASSWORD 'scofield';
GRANT readwrite TO scofield;


4) attribuer un OWNER à une DATABASE

REP : 
CREATE DATABASE db_anakin WITH OWNER anakin ENCODING='UTF8'; 

5) Modifier le OWNER de la DB vers un autre OWNER

REP :ALTER DATABASE db_anakin OWNER TO postgres;

6) faire une conversion de type de data 

REP : (ST_Area(b.the_geom))::int as surface_buildings

7) add une clé primaire non-nulle qui s'autoincrémente

REP : pk_id serial primary key not null

8) transformer une donnée geometry en text

REP : ST_AsText(ST_CENTROID(b.the_geom)) as text_centroid

9) créer une contrainte de clés primaires entre 2 tables

REP :
CREATE TABLE IF NOT EXISTS test (
	id serial primary key not null,
	nom_structure text,
	id_libelle int not null,
	CONSTRAINT fk_libelle
		FOREIGN KEY (id_libelle)
			REFERENCES libelle(pk_id)
)

ça ne fonctionne que si la table externe possède une clé unique
dc only avc un champ ID serial primary key

10) placer une apostrophe ds un format TEXT en SQL

REP : doubler l'apostrophe ds la chaîne de caractère

11) en psql lister les roles/schemas/tables/extensions d'1 DB

REP : \du ou \du+, \dn, \dt ou \dp, \dx, \ds (sequences)

12) se connecter à 1 DB précise en PSQL

REP: \c db_name


13) quitter psql

REP : \q

14) est-ce que le UNIQUE(champ1, champ2, ...) fonctionne ?

REP : NON, faut add UNIQUE to each champ qui en nécessite

15) pr suppr une valeur ou catégorie de valeur d'1 seule table

REP : DELETE FROM public.detection WHERE id_detection = 2;

16) créer une table à partir d'un SELECT STATEMENT

REP : 
CREATE TABLE IF NOT EXISTS buildings_bis AS (
	SELECT *
	FROM td_postgis.buildings
)


17) pr modifier une contrainte :

REP : can't ma modifier direct, fo la suppr puis la recréer

ALTER TABLE IF EXISTS joueurs
DROP CONSTRAINT fk_club_joueur, 
ADD CONSTRAINT fk_club_joueur 
	FOREIGN KEY (club_pro) REFERENCES clubs(nom) 
	ON UPDATE RESTRICT;

18) pr add une double contrainte on update/on delete :


REP : ADD CONSTRAINT fk_club_joueur 
	FOREIGN KEY (club_pro) REFERENCES clubs(nom) 
	ON UPDATE CASCADE ON DELETE CASCADE;

19) pr copier les data d'un CSV vers une table PG :

REP :
COPY sample_table_name
FROM 'C:\sampledb\sample_data.csv' 
DELIMITER ',' 
CSV HEADER;

20) pr changer le type d'une colonne d'une table :

REP : 
ALTER TABLE table_name
ALTER COLUMN column_name1 TYPE new_data_type

21) to drop a constraint UNIQUE dont on a pas précisé le nom :

REP :
- pr trouver son nom :
	SELECT conname
	FROM pg_constraint
	WHERE conrelid = 'nom_de_la_table'::regclass
	AND contype = 'u';
- pr suppr la contrainte :
ALTER TABLE nom_de_la_table
DROP CONSTRAINT nom_de_la_contrainte;

22) pr modifier la valeur d'1 colonne AGE sur all lignes de
    la table JOUEURS

REP :
UPDATE joueurs
SET age = 10;

23) créer une table à partir d'1 selection :

REP : CREATE TABLE IF NOT EXISTS public.pays AS 
	SELECT * FROM bis_schema.pays


24) pr update un champ avec des valeurs RANDOM entre 0 et 1 MS 
sans changer de type

REP :
UPDATE salaires
SET taux = random();


25) pr update plusieurs champs d'1 mm table :

REP : 
UPDATE salaires
SET champ1 = ROUND(random()::numeric, 2), champ2 = random();


26) pour réinitialiser une séquence

REP :
ALTER SEQUENCE nom_sequence RESTART;

27) INSERT INTO la table d'un schema B à partir de la mm table du 
schema A mais avec une clé primaire qui commence à 1 tandis que
la clé primaire de la table du schema A commence à 100 :

REP :
INSERT INTO schemaB.table
	SELECT ROW_NUMBER() OVER(id) as id, champ1, champ2
	FROM schemaA.table;

28) pr suppr des lignes d'1 table

REP :
DELETE FROM table1
WHERE condition;

29) pr suppr l'extension postgis de la DB :

REP :
DROP extension Postgis;

30) pr changer le schema d'accueil de postgis vers un new schema

REP :
ALTER DATABASE db_name SET search_path = public, new_schema

31) suppr doublons de la table detection

REP :
DELETE FROM
	detection a
		USING detection b
WHERE a.id < b.id AND a.id_detection = b.id_detection;

32) pr update les champs d'1 table detection à partir des données
de la mm table detection d'un autre schema

REP:
UPDATE schema2.detec AS d1
SET occ_detec = d2.occ_detec
FROM (
	SELECT *
	FROM schema1.detec

33) pr changer postgis de schema

REP:
-- création de l'extensin
CREATE EXTENSION postgis;
  
-- mise à jour de l'extension postgis
UPDATE pg_extension 
  SET extrelocatable = TRUE 
    WHERE extname = 'postgis';
 
-- on changer de schema
ALTER EXTENSION postgis 
  SET SCHEMA test;

-- select la version used de Postgis
SELECT test.PostGIS_Version();

-- vérifie que la version de postgis est bien la bonne
ALTER EXTENSION postgis 
  UPDATE TO "2.5.3";

-- si on souhaite créer une table dans le schema public MM si 
-- postgis ds other schema : fo préciser le schema having le type
-- geometry ds la création du champs
CREATE TABLE IF NOT EXISTS pays (
	id serial primary key not null,
	nom varchar(255) UNIQUE,
	geom test.geometry
);

-- pr insérer des valeurs 
INSERT INTO pays (nom, geom) 
VALUES ('algerie', 'POINT(0 0)');

sauf que si on fait un inspect db sur le schema public qui 
contient pas postgis, la commande va pas fonctionner
==> fo donc ajouter le search_path en options ds 'OPTIONS' ds le
module DATABASES du settings.py

34) faire tourner postgis sur 2 schemas différents sur 1 mm DB

REP: impossible (j'ai testé sur le schema public et un 2nd schema
                 test et impossible de recréer l'extension postgis
                 sur public)

35) pr add une colonne :

REP:
ALTER TABLE my_table
ADD COLUMN new_column integer;

/!\ attention, dès qu'on a ajouté une colonne ds une table qui
possède déjà des lignes, automatiquement PG leur donne des
valeurs nulles NULL => dc on peut pas mettre une contrainte
NOT NULL au moment de la création de la colonne ! il faut update
les valeurs de la colonne puis faire un :
ALTER TABLE new_table
ALTER COLUMN new_column SET NOT NULL;

36) pr modifier des valeurs selon des conditions (as IF/ELSE):

REP :
UPDATE test.pays
SET nom = CASE
		WHEN id = 12 THEN 'yemen'
		WHEN id = 13 THEN 'eau'
		ELSE nom
	END;

/!\ pr un UPDATE + complexe avec jointure :
UPDATE test.demographie AS d
SET population = CASE
			WHEN p.nom = 'algerie' THEN 45
			WHEN p.nom = 'egypte' THEN 100
			ELSE population
		END
FROM test.pays AS p
WHERE d.pays = p.nom;
--ne pas mettre l'indicateur 'd.' dans le SET ni le ELSE 
--MAIS only ds le WHERE

37) pr créer/suppr un schéma:

REP:
CREATE SCHEMA testbis;
DROP SCHEMA testbis;

38) pr compter le nombre de vertex d'1 polygone

REP : compter son nombre de points
SELECT SUM(ST_NPoints(geom))
FROM my_table;

39) pour créer/suppr un schema

REP:
CREATE SCHEMA testbis;
DROP SCHEMA testbis;

40) pr réunir 2 select d'1 mm table ds une seule table (requête
combinée) :

REP:
SELECT *
	FROM test.pays
	WHERE nom = 'algerie'
UNION
SELECT *
	FROM test.pays
	WHERE nom = 'tunisie'
/!\ MS si on veut placer un LIMIT ou ORDER BY ds un des SELECT
faut mettre la requête entre parenthèses:
(SELECT *
	FROM test.pays
	LIMIT 10)
UNION
SELECT *
	FROM test.pays
	WHERE nom = 'tunisie'

/!\ au UNION ALL qui, dans le cas où on a 2 lignes identiques sur
les 2 tables, va doubler cette ligne identique sur la table
résultant de la requête combinée

41) pour lire le search_path :

REP:
SHOW search_path(); => par défaut c'est le schema public

42) pr remettre par défaut le GUI PgAdmin :

REP:
file > reset layout

43) quelle diff entre != et <> ?

REP:
aucune

44) pr filtrer la diff entre 2 select (called COMBINING QUERIES ou
requêtes combinées) :

REP:
SELECT *
FROM table1
	INTERSECT
SELECT *
FROM table2;

45) pr select que les data dispo ds table1 et absentes de table2:

REP:
SELECT *
FROM table1
	EXCEPT
SELECT *
FROM table2;

46) l'équivalent du PROJECT operator :

REP:
SELECT DISTINCT, avec le DISTINCT qui permet d'éliminer les
duplicatas ou copies

47) l'équivalent du RENAME operator en algèbre relationnel:

REP:
AS

48) pr créer une séquence customisée:

REP:
CREATE SEQUENCE mysequence
INCREMENT 5
START 100;

49) qd utilise-t-on nextval() ?

REP:
pr manipuler des séquences

50) créer une fonction simple en SQL

REP:
CREATE OR REPLACE FUNCTION quick_select (i varchar) 
RETURNS TABLE (id integer, pays varchar) AS
$$
	SELECT *
	FROM table1
	WHERE pays = i
$$
LANGUAGE SQL;

-- pr appeler la fonction:
SELECT quick_select('algerie');
-- pr suppr la fonction:
DROP FUNCTION quick_select(i varchar);

/!\ pr créer des fct + complexes fo passer en PL/pgsql if need par
exemple des var à déclarer, des boucle for loop etc

51) quels sont les 3 composantes de SQL ?

REP:
- DDL: data definition language
- DML: data manipulation language (INSERT UPDATE DELETE SELECT)
- DCL: data control language
--sinon, SELECT, UPDATE etc st des KEYWORDS whereas TABLE, SCHEMA
etc st des IDENTIFIERS soit des noms d'objets de la DB

52) how appelle-t-on un SELECT où tu listes les champs ?

REP:
un select-list

53) pr créer une RULE qui ordonne l'insertion de données ds la
table2 après insertion des mm données ds table1 :

REP:
CREATE OR REPLACE RULE add_pays_asie_on_table2
AS ON INSERT TO table1
DO
INSERT INTO table2(pays)
VALUES (new.pays);
 
INSERT INTO table1 (pays)
VALUES ('djibouti'); ==> ça marche !

54) insérer des données géométriques ds une table via SQL

REP:
INSERT INTO mediatrices(nom, geom)
VALUES ('hicham', 'LINESTRING(0 1, 2 1)'::geometry);

55) définir une valeur par défaut pour une colonne précise

REP:
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric DEFAULT 9.99
);

56) pr mettre à jour la valeur par défaut d'une colonne et mettre
à false les valeurs déjà entrées:

REP:
ALTER TABLE i.voiture
ALTER COLUMN cabriolet SET DEFAULT False;
UPDATE i.voiture
SET cabriolet = false;